从内存分配的角度看，ByteBuf可以分为两类：
（1）堆内存（HeapByteBuf）字节缓冲区：特点是内存的分配和回收速度快，可以被JVM自动回收；缺点就是如果进行Socket的I/O读写，需要额外
做一次内存复制，将堆内存对应的缓冲区复制到内核Channel中，性能会有一定的下降

（2）直接内存（DirectByteBuf）字节缓冲区：非堆内存，它在堆外进行内存分配，相比于堆内存，它的分配和回收速度会慢一些，但是将它写入或者从
Socket Channel中读取时，由于少了一次内存复制，速度比堆内存快。

ByteBuf的最佳实践是在I/O通信线程的读写缓冲区使用DirectByteBuf，后端业务消息的编解码模块使用HeapByteBuf，这样组合可以达到性能最优。


从内存回收角度看，ByteBuf也分为两类：
（1）基于对象池的ByteBuf和普通ByteBuf
两者主要区别就是基于对象池的ByteBuf可以重用ByteBuf对象，它自己维护了一个内存池，可以循环
利用创建的ByteBuf，提升内存的使用效率，降低由于高负载导致的频繁GC。


